<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Role Play</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <!-- PDF libs (use jsDelivr without SRI to avoid integrity mismatch) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="/static/feedback-widget.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <!-- DOCX lib -->
  <script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js"></script>
  <!-- Prevent favicon 404 using a tiny inline data URL -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14' font-size='14'%3E%F0%9F%8C%88%3C/text%3E%3C/svg%3E">
</head>
<body class="bg-gray-100">
  <div class="container mx-auto px-4 py-10 max-w-3xl">
    <div id="card" class="bg-white rounded-lg shadow p-6">
      <h1 class="text-2xl font-semibold mb-2">Role Play</h1>
      {% if unit %}
        <p class="text-sm text-gray-600 mb-1">Unit: <strong>{{ unit.title }}</strong></p>
        <div id="rp-instructions" class="mb-2 p-3 bg-blue-50 border border-blue-200 rounded text-sm text-gray-800"></div>
      {% endif %}
      <!-- Student name input moved here (below title and instructions) -->
      <div class="mb-3">
        <input id="student-name" type="text" class="p-2 border rounded text-sm" placeholder="Student Name (required)" style="min-width: 16rem;" />
      </div>
      <div id="transcript" class="border rounded p-3 h-80 overflow-y-auto bg-gray-50 mb-3"></div>
      <div class="flex items-center gap-2 mb-2">
        <input id="text-input" type="text" class="flex-1 p-2 border rounded" placeholder="Type your line in Chinese or English..." />
        <button id="whisper-mic" class="bg-green-600 text-white px-3 py-2 rounded hover:bg-green-700">üé§ Voice</button>
        <button id="send" class="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700">Type</button>
      </div>
      <!-- Speech recognition suggestions -->
      <div id="speech-suggestions" class="hidden mb-2 p-3 bg-yellow-50 border border-yellow-200 rounded">
        <div class="text-sm text-gray-700 mb-2">Did you mean one of these?</div>
        <div id="suggestion-buttons" class="flex flex-wrap gap-2"></div>
      </div>
      <div class="flex items-center gap-3 text-sm text-gray-600">
        <span id="error" class="text-red-700"></span>
        <span id="speech-status" class="text-blue-600"></span>
      </div>
      <div class="mt-3 flex items-center gap-3">
        <button id="finish" class="bg-green-600 text-white px-3 py-2 rounded hover:bg-green-700 text-sm">Finish & Feedback</button>
        <button id="saveDocx" class="bg-indigo-600 text-white px-3 py-2 rounded hover:bg-indigo-700 text-sm">Save DOCX</button>
        <span id="status" class="text-sm text-gray-500"></span>
      </div>
      <div id="feedback" class="mt-4 hidden border rounded p-3 bg-green-50">
        <h2 class="font-semibold mb-2">End-of-Conversation Feedback</h2>
        <div id="feedbackBody" class="whitespace-pre-wrap text-sm"></div>
      </div>
      <div class="mt-4"><a href="/select?unit={{ unit_id }}" class="text-blue-600 hover:underline">‚Üê Back to activity choice</a></div>
    </div>
  </div>

  <script>
    const unitId = '{{ unit_id }}';
    // Render English-only instructions below the unit title (outside chatbot)
    (function renderEnglishInstructions(){
      try{
        const el = document.getElementById('rp-instructions');
        if (!el) return;
        const textByUnit = {
          'unit1': (
            'Instructions (English):\n' +
            '- Student asks the questions first.\n' +
            '- Emily answers only what you ask (no extra info).\n' +
            '- Use Voice button for speech recognition (powered by OpenAI Whisper)\n' +
            '- Emily speaks Chinese with pinyin; English only on request.\n' +
            '- Suggested first question: Ask Emily Chinese name.\n' +
            '- Record your conversation and write down Emily‚Äôs responses in Chinese in your handout.'
          ),
          'unit2': (
            'Instructions (English):\n' +
            '- Student asks the questions first.\n' +
            '- Emily answers only what you ask (no extra info).\n' +
            '- Stay on Unit 2 topics (family size, members, siblings, pets, ages).\n' +
            '- Use Voice button for speech recognition (powered by OpenAI Whisper)\n' +
            '- Emily speaks Chinese with pinyin; English only on request.\n' +
            '- Suggested first question: How many people are in your family? Who are they?\n' +
            '- Record your conversation and write down Emily‚Äôs responses in Chinese in your handout.'
          ),
          'unit3': (
            'Instructions (English):\n' +
            '- Student asks the questions first.\n' +
            '- Emily answers only what you ask (no extra info).\n' +
            '- Focus on schedule (days, dates, classes, activities, times).\n' +
            '- Use Voice button for speech recognition (powered by OpenAI Whisper)\n' +
            '- Emily speaks Chinese with pinyin; English only on request.\n' +
            '- Suggested first question: What classes/activities do you have today?\n' +
            '- Record your conversation and write down Emily‚Äôs responses in Chinese in your handout.'
          )
        };
        const text = textByUnit[unitId] || (
          'Instructions (English):\n- Student asks first.\n- Emily answers only what you ask.\n- Emily speaks Chinese with pinyin; English only on request.\n- Record your conversation and write down Emily‚Äôs responses in Chinese in your handout.'
        );
        el.innerText = text;
      } catch {}
    })();
    const state = { history: [], assistantTurn: 0, helpShownFor: {}, helpShownSinceLastResponse: false, startedAt: null, completedMs: null };
    // Gate autoplay until any user interaction happens (fix NotAllowedError)
    let hasUserInteracted = false;
    ['pointerdown','keydown','touchstart'].forEach(evt => {
      window.addEventListener(evt, () => { hasUserInteracted = true; }, { once: true, passive: true });
    });
    let inactivityTimer = null;
    function scheduleInactivityPrompt(turnId) {
      clearTimeout(inactivityTimer);
      // After assistant speaks, wait 90 seconds for the student; then show help ONLY if truly inactive
      inactivityTimer = setTimeout(() => {
        // Only show help if we haven't shown it since the last student response AND student hasn't responded at all
        if (state.helpShownSinceLastResponse) return;
        
        // Check if this is true inactivity (no student responses for 90 seconds)
        // If student has been responding (even just answers), don't show help
        const lastUserMessage = state.history.slice().reverse().find(msg => msg.role === 'user');
        const lastAssistantMessage = state.history.slice().reverse().find(msg => msg.role === 'assistant');
        
        // Only show help if there's been no user activity after the last assistant message
        if (lastUserMessage && lastAssistantMessage) {
          const userIndex = state.history.lastIndexOf(lastUserMessage);
          const assistantIndex = state.history.lastIndexOf(lastAssistantMessage);
          if (userIndex > assistantIndex) {
            // Student responded after assistant, so they're active - don't show help
            return;
          }
        }
        
        // Mark that we've shown help and insert unit-specific question suggestions (no autoplay)
        const unitSuggestions = {
          'unit1': "‰Ω†ÂèØ‰ª•ÈóÆÊàëÊàëÁöÑÂêçÂ≠ó„ÄÅÊàëÁöÑÂ∑•‰Ωú„ÄÅÊàëÁöÑÊúãÂèãÈ´òÂ±±„ÄÅÊàëÁöÑÁîµËØùÂè∑Á†ÅÔºåÊàñËÄÖÊàëÂøô‰∏çÂøô„ÄÇ(N«ê kƒõy«ê w√®n w«í w«í de m√≠ngz√¨, w«í de g≈çngzu√≤, w«í de p√©ngy«íu GƒÅoshƒÅn, w«í de di√†nhu√† h√†om«é, hu√≤zhƒõ w«í m√°ng b√π m√°ng.) You can ask me about my name, my job, my friend Gordon, my phone number, or if I'm busy.",
          'unit2': "‰Ω†ÂèØ‰ª•ÈóÆÊàëÊàëÁöÑÂÆ∂‰∫∫„ÄÅÊàëÂÆ∂ÊúâÂá†Âè£‰∫∫„ÄÅÊàëÁà∏Áà∏Â¶àÂ¶àÂ§öÂ∞ëÂ≤Å„ÄÅÊàëÊúâÊ≤°ÊúâÂÖÑÂºüÂßêÂ¶πÊàñËÄÖÊàëÁöÑÂÆ∂‰∫∫ÁöÑÂ∑•‰Ωú„ÄÇ(N«ê kƒõy«ê w√®n w«í w«í de jiƒÅr√©n, w«í jiƒÅ y«íu j«ê k«íu r√©n, w«í b√†ba mƒÅma du≈çshao su√¨, w«í y«íu m√©iy«íu xi≈çngd√¨ jiƒõm√®i hu√≤zhƒõ w«í de jiƒÅr√©n de g≈çngzu√≤.) You can ask me about my family, how many people are in my family, how old my parents are, if I have siblings, or about my family members' jobs.",
          'unit3': "‰Ω†ÂèØ‰ª•ÈóÆÊàë‰ªäÂ§©ÁöÑËØæÁ®ã„ÄÅÊàëÂá†ÁÇπËµ∑Â∫ä„ÄÅÊàëÂë®Êú´ÂÅö‰ªÄ‰πàÊàñËÄÖÊàëÁöÑÊó∂Èó¥ÂÆâÊéí„ÄÇ(N«ê kƒõy«ê w√®n w«í jƒ´ntiƒÅn de k√®ch√©ng, w«í j«ê di«én q«êchu√°ng, w«í zh≈çum√≤ zu√≤ sh√©nme hu√≤zhƒõ w«í de sh√≠jiƒÅn ƒÅnp√°i.) You can ask me about today's classes, what time I wake up, what I do on weekends, or my schedule."
        };
        const promptLine = unitSuggestions[unitId] || "‰Ω†ÂèØ‰ª•ÈóÆÊàëÂÖ≥‰∫éËøô‰∏™ÂçïÂÖÉÁöÑËØùÈ¢ò„ÄÇ(N«ê kƒõy«ê w√®n w«í guƒÅny√∫ zh√®ge dƒÅnyu√°n de hu√†t√≠.) You can ask me about topics from this unit.";
        addLine('assistant', promptLine, { autoplay: false });
        state.history.push({ role:'assistant', content: promptLine });
        state.helpShownSinceLastResponse = true;
      }, 90000);
    }

    // Render helper: when hideEnglish is true, keep only Chinese + pinyin (up to last closing parenthesis) per line
    function renderForDisplay(text, hideEnglish = false) {
      if (!hideEnglish) return text;
      return (text || '')
        .split(/\n/g)
        .map(line => {
          const idx = line.lastIndexOf(')');
          if (idx !== -1) return line.slice(0, idx + 1).trim();
          // No pinyin pattern found; best-effort: return the line as-is (could be pure Chinese)
          return line;
        })
        .join('\n');
    }

    // Remove pinyin in parentheses to show Chinese-only
    function stripPinyin(text) {
      if (!text) return '';
      // Remove parenthetical pinyin segments like " (n«ê h«éo)"
      // Then remove multiple spaces left behind
      return text.replace(/\s*\([^)]*\)/g, '').replace(/\s+/g, ' ').replace(/\s*\n\s*/g, '\n').trim();
    }

    // Extract pinyin-only block: for each line, collect parenthetical pinyin
    function extractPinyin(text) {
      if (!text) return '';
      const lines = (text || '').split(/\n/g);
      const out = [];
      for (const line of lines) {
        const parts = [];
        const regex = /\(([^)]*)\)/g;
        let m;
        while ((m = regex.exec(line)) !== null) {
          const seg = (m[1] || '').trim();
          if (seg) parts.push(seg);
        }
        if (parts.length) out.push(parts.join(' '));
      }
      return out.join('\n');
    }

    // Finish & Feedback handler
    document.getElementById('finish').addEventListener('click', async () => {
      try {
        document.getElementById('status').textContent = 'Generating feedback‚Ä¶';
        const res = await fetch('/activity/roleplay/feedback', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ unitId, history: state.history })
        });
        const data = await res.json();
        if (!res.ok || data.error) { document.getElementById('error').textContent = data.error || 'Failed to get feedback'; document.getElementById('status').textContent=''; return; }
        // Stop timer
        if (state.startedAt && state.completedMs == null) {
          state.completedMs = Date.now() - state.startedAt;
        }
        const fbWrap = document.getElementById('feedback');
        const fbBody = document.getElementById('feedbackBody');
        fbBody.textContent = data.feedback || 'No feedback available.';
        fbWrap.classList.remove('hidden');
        // Show completion time in status
        const mins = state.completedMs ? Math.floor(state.completedMs/60000) : 0;
        const secs = state.completedMs ? Math.floor((state.completedMs%60000)/1000) : 0;
        const tStr = state.completedMs != null ? `Time: ${mins}m ${secs}s. ` : '';
        document.getElementById('status').textContent = `${tStr}Feedback ready. Reminder: save your log, complete your handout, and upload the handout, the log, and the video.`;
      } catch (e) {
        document.getElementById('error').textContent = 'Error getting feedback';
        document.getElementById('status').textContent='';
      }
    });

    function addLine(role, content, options = {}) {
      const wrap = document.getElementById('transcript');
      const row = document.createElement('div');
      row.className = `mb-2 ${role === 'user' ? 'text-right' : ''}`;
      const bubble = document.createElement('div');
      bubble.className = `inline-block px-3 py-2 rounded text-gray-900 ${role === 'user' ? 'bg-blue-100' : 'bg-gray-200'}`;
      // Separate content container from controls so we can re-render text without losing controls
      const contentEl = document.createElement('div');
      contentEl.dataset.original = content; // legacy key
      contentEl.dataset.originalCn = content; // Chinese + pinyin (as returned by assistant)
      const chineseOnly = stripPinyin(content);
      contentEl.dataset.chineseOnly = chineseOnly;
      contentEl.dataset.pinyinOnly = extractPinyin(content);
      contentEl.dataset.english = '';
      contentEl.dataset.showPinyin = 'false';
      if (role !== 'user') {
        contentEl.dataset.role = 'assistant';
        // If this is the opening instruction, allow showing English initially
        const initialShowEnglish = options.showEnglish === true ? 'false' : 'true';
        contentEl.dataset.hideEnglish = initialShowEnglish;
      }
      contentEl.className = 'whitespace-pre-wrap';
      const hideEng = (role !== 'user') ? (contentEl.dataset.hideEnglish === 'true') : false;
      // For assistant lines:
      // - Opening: show Chinese-only (no pinyin, no English) by default
      // - Normal chats: show Chinese-only by default
      let initialText = content;
      if (role !== 'user') {
        if (options.opening === true) {
          initialText = chineseOnly;
        } else if (!options.showEnglish) {
          initialText = chineseOnly;
        }
      }
      const displayText = (role !== 'user') ? (hideEng ? renderForDisplay(initialText, true) : initialText) : content;
      contentEl.innerHTML = displayText.replace(/\n/g, '<br>');
      bubble.appendChild(contentEl);
      if (role !== 'user') {
        const controls = document.createElement('div');
        controls.className = 'mt-2 flex items-center gap-2';
        const play = document.createElement('button');
        play.textContent = '‚ñ∂Ô∏è Play audio';
        play.className = 'text-xs bg-gray-300 hover:bg-gray-400 px-2 py-1 rounded';
        const pauseBtn = document.createElement('button');
        pauseBtn.textContent = '‚è∏ Pause';
        pauseBtn.className = 'text-xs bg-gray-300 hover:bg-gray-400 px-2 py-1 rounded';
        // Discrete speed toggle (0.75x, 1x, 1.25x)
        const speedWrap = document.createElement('label');
        speedWrap.className = 'text-xs flex items-center gap-1';
        speedWrap.textContent = 'Speed';
        const speedSel = document.createElement('select');
        speedSel.className = 'text-xs border rounded px-1 py-0.5';
        speedSel.setAttribute('data-speed', 'select');
        [['0.75','0.75x'], ['1.0','1x'], ['1.25','1.25x']].forEach(([val,label])=>{
          const opt = document.createElement('option'); opt.value = val; opt.textContent = label; if (val==='1.0') opt.selected=true; speedSel.appendChild(opt);
        });
        play.onclick = () => playTTS((options.showEnglish ? contentEl.dataset.originalCn : contentEl.dataset.chineseOnly) || content, speedSel.value);
        pauseBtn.onclick = () => pauseTTS();
        // Append play first, then speed toggle
        controls.appendChild(play);
        controls.appendChild(pauseBtn);
        speedWrap.appendChild(speedSel);
        controls.appendChild(speedWrap);
        // Per-bubble Show/Hide Pinyin toggle
        const pinyinBtn = document.createElement('button');
        pinyinBtn.className = 'text-xs bg-gray-100 text-gray-900 px-2 py-1 rounded hover:bg-gray-200';
        pinyinBtn.textContent = 'Show Pinyin';
        pinyinBtn.addEventListener('click', () => {
          const showing = contentEl.dataset.showPinyin === 'true';
          const next = !showing; contentEl.dataset.showPinyin = next ? 'true' : 'false';
          pinyinBtn.textContent = next ? 'Hide Pinyin' : 'Show Pinyin';
          const cnOnly = contentEl.dataset.chineseOnly || '';
          const pinyinBlock = contentEl.dataset.pinyinOnly || '';
          const eng = (contentEl.dataset.hideEnglish === 'false') ? (contentEl.dataset.english || '') : '';
          let composed = cnOnly;
          if (next && pinyinBlock) composed += '\n\n' + pinyinBlock;
          if (eng) composed += '\n\n' + eng;
          contentEl.innerHTML = composed.replace(/\n/g, '<br>');
        });
        controls.appendChild(pinyinBtn);

        // Per-bubble Hide/Show English toggle (optional)
        if (options.allowEnglishToggle !== false) {
          const toggleBtn = document.createElement('button');
          toggleBtn.className = 'text-xs bg-yellow-100 text-gray-900 px-2 py-1 rounded hover:bg-yellow-200';
          toggleBtn.textContent = (contentEl.dataset.hideEnglish === 'true') ? 'Show English' : 'Hide English';
          toggleBtn.addEventListener('click', async () => {
            const currentlyHidden = contentEl.dataset.hideEnglish === 'true';
            const nextHidden = !currentlyHidden;
            contentEl.dataset.hideEnglish = nextHidden ? 'true' : 'false';
            toggleBtn.textContent = nextHidden ? 'Show English' : 'Hide English';
            // Use current Pinyin visibility to decide base text
            const showPinyin = contentEl.dataset.showPinyin === 'true';
            const cn = showPinyin ? (contentEl.dataset.originalCn || '') : (contentEl.dataset.chineseOnly || '');
            // If we are going to SHOW English and don't have it yet, fetch a gloss
            if (!nextHidden && !contentEl.dataset.english) {
              try {
                toggleBtn.disabled = true; toggleBtn.textContent = 'Loading‚Ä¶';
                const res = await fetch('/activity/roleplay/translate', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ text: contentEl.dataset.originalCn || cn }) });
                const data = await res.json();
                if (res.ok && !data.error && data.english) {
                  contentEl.dataset.english = data.english;
                } else {
                  contentEl.dataset.english = '(English gloss unavailable)';
                }
              } catch (e) {
                contentEl.dataset.english = '(English gloss unavailable)';
              } finally {
                toggleBtn.disabled = false; toggleBtn.textContent = 'Hide English';
              }
            }
            const eng = contentEl.dataset.english || '';
            const composed = nextHidden ? cn : (cn + (eng ? ('\n' + eng) : ''));
            contentEl.innerHTML = composed.replace(/\n/g, '<br>');
          });
          controls.appendChild(toggleBtn);
        }
        bubble.appendChild(controls);
      }
      row.appendChild(bubble);
      wrap.appendChild(row);
      wrap.scrollTop = wrap.scrollHeight;
      // If assistant spoke, autoplay audio (unless disabled) and start inactivity timer; if user spoke, clear it
      if (role !== 'user') {
        if (options.autoplay !== false && (hasUserInteracted || options.opening === true)) {
          try {
            const sel = bubble.querySelector('select[data-speed]');
            const rate = sel ? sel.value : '1.0';
            // Use original text to allow English names; playTTS will remove pinyin parentheses
            playTTS(contentEl.dataset.originalCn || content, rate);
          } catch {}
        }
        // Register a new assistant turn and schedule per-turn assistance prompt
        state.assistantTurn = (state.assistantTurn || 0) + 1;
        scheduleInactivityPrompt(state.assistantTurn);
      } else {
        clearTimeout(inactivityTimer);
      }
    }

    async function startRoleplay() {
      const res = await fetch('/activity/roleplay/start', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ unitId }) });
      const data = await res.json();
      if (!res.ok || data.error) { document.getElementById('error').textContent = data.error || 'Failed to start'; return; }
      // Start timer on first load
      if (!state.startedAt) state.startedAt = Date.now();
      const instruction = (data.instruction || '').trim();
      const greeting = (data.greeting || '').trim();
      const firstQ = (data.firstQuestion || '').trim();
      // We no longer display the instruction line inside the chatbot bubbles.
      if (greeting || firstQ) {
        if (greeting) {
          addLine('assistant', greeting, { autoplay: true, opening: true });
          state.history.push({ role:'assistant', content: greeting });
          if (hasUserInteracted) { try { await waitForAudioEnd(); } catch {} }
        }
        // Do NOT send the first question from Emily; students must ask first.
      } else {
        // Backward compatibility: use combined opening if provided
        const opening = (data.opening || '').trim();
        if (opening) {
          addLine('assistant', opening, { opening: true, showEnglish: false, allowEnglishToggle: true });
          state.history.push({ role:'assistant', content: opening });
        }
      }
    }

    async function sendText() {
      const input = document.getElementById('text-input');
      const message = input.value.trim(); if (!message) return; 
      
      // Hide suggestions and reset input styling
      hideSuggestions();
      input.value='';
      input.style.fontStyle = 'normal';
      input.style.color = 'black';
      
      addLine('user', message); state.history.push({ role:'user', content: message });
      // Reset help flag when student responds
      state.helpShownSinceLastResponse = false;
      const res = await fetch('/activity/roleplay/turn', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ unitId, history: state.history, message }) });
      const data = await res.json();
      if (!res.ok || data.error) { document.getElementById('error').textContent = data.error || 'Failed to continue'; return; }
      addLine('assistant', data.reply); state.history.push({ role:'assistant', content: data.reply });
    }

    document.getElementById('send').addEventListener('click', sendText);
    document.getElementById('text-input').addEventListener('keyup', (e)=>{ if (e.key==='Enter') sendText(); });
    
    // Hide suggestions when user starts typing manually
    document.getElementById('text-input').addEventListener('input', (e) => {
      // Only hide if the user is manually typing (not from speech recognition)
      if (e.target.style.fontStyle !== 'italic') {
        hideSuggestions();
      }
    });

    // Removed global toggle; per-bubble toggle is added inside each assistant message

    // Whisper API voice input (more accurate for Mandarin)
    const whisperMicBtn = document.getElementById('whisper-mic');
    let mediaRecorder = null;
    let audioChunks = [];
    let isWhisperRecording = false;

    whisperMicBtn.onclick = async () => {
      try {
        if (!isWhisperRecording) {
          // Start recording
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];
          
          mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
          };
          
          mediaRecorder.onstop = async () => {
            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            await sendToWhisper(audioBlob);
            
            // Stop all tracks to release microphone
            stream.getTracks().forEach(track => track.stop());
          };
          
          mediaRecorder.start();
          isWhisperRecording = true;
          whisperMicBtn.textContent = 'üõë Stop Whisper';
          whisperMicBtn.className = 'bg-red-600 text-white px-3 py-2 rounded hover:bg-red-700';
          document.getElementById('speech-status').textContent = 'Recording with Whisper...';
          
        } else {
          // Stop recording
          mediaRecorder.stop();
          isWhisperRecording = false;
          whisperMicBtn.textContent = 'üé§ Whisper';
          whisperMicBtn.className = 'bg-green-600 text-white px-3 py-2 rounded hover:bg-green-700';
          document.getElementById('speech-status').textContent = 'Processing...';
        }
      } catch (e) {
        document.getElementById('error').textContent = 'Microphone access denied or not available';
        console.error('Whisper recording error:', e);
      }
    };

    async function sendToWhisper(audioBlob) {
      try {
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.wav');
        formData.append('unitId', unitId);
        
        const response = await fetch('/activity/roleplay/whisper', {
          method: 'POST',
          body: formData
        });
        
        const data = await response.json();
        
        if (response.ok && data.success) {
          const input = document.getElementById('text-input');
          input.value = data.text;
          input.style.fontStyle = 'normal';
          input.style.color = 'black';
          document.getElementById('speech-status').textContent = 'Speech recognized successfully!';
          
          // Auto-send the recognized text
          setTimeout(() => {
            sendText();
          }, 500);
        } else {
          document.getElementById('error').textContent = data.error || 'Speech recognition failed';
          document.getElementById('speech-status').textContent = '';
        }
      } catch (e) {
        document.getElementById('error').textContent = 'Error processing speech';
        document.getElementById('speech-status').textContent = '';
        console.error('Whisper API error:', e);
      }
    }

    // Voice input now uses only Whisper API (browser speech recognition removed)

    // Reuse TTS from index page if available; otherwise provide minimal version
    let currentAudio = null;
    async function playTTS(text, rate = '1.0') {
      return new Promise(async (resolve) => {
        try {
          // Keep Chinese and English names; remove parenthetical pinyin only
          const speakText = text.replace(/\([^)]*\)/g, '').replace(/\s+/g,' ').trim();
          if (!speakText) { resolve(); return; }
          const res = await fetch('/tts',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ text: speakText, voice: 'alloy' })});
          const blob = await res.blob();
          const url = URL.createObjectURL(blob);
          if (currentAudio) { try { currentAudio.pause(); } catch {} }
          const audio = new Audio(url);
          audio.playbackRate = Number(rate) || 1.0;
          currentAudio = audio;
          const playPromise = audio.play();
          if (playPromise && typeof playPromise.then === 'function') {
            playPromise.then(() => {
              audio.onended = () => { try { URL.revokeObjectURL(url); } catch {} resolve(); };
            }).catch(() => { try { URL.revokeObjectURL(url); } catch {} resolve(); });
          } else {
            // If browser doesn't return a promise, resolve onended or quickly
            audio.onended = () => { try { URL.revokeObjectURL(url); } catch {} resolve(); };
            setTimeout(()=>resolve(), 100); // safety fallback
          }
        } catch {
          resolve();
        }
      });
    }

    function waitForAudioEnd() {
      return new Promise((resolve) => {
        try {
          if (!currentAudio) { resolve(); return; }
          // If no audio is playing, resolve immediately
          if (currentAudio.paused) { resolve(); return; }
          const onEnd = () => { try { currentAudio.onended = null; } catch {} resolve(); };
          currentAudio.onended = onEnd;
        } catch { resolve(); }
      });
    }

    function pauseTTS() {
      try { if (currentAudio) currentAudio.pause(); } catch {}
    }

    // Speech recognition suggestion system
    async function showSpeechSuggestions(recognizedText) {
      try {
        document.getElementById('speech-status').textContent = 'Getting suggestions...';
        
        const res = await fetch('/activity/roleplay/speech-assist', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text: recognizedText, unitId })
        });
        
        const data = await res.json();
        if (!res.ok || data.error) {
          console.log('Speech assist error:', data.error);
          return;
        }
        
        if (data.suggestions && data.suggestions.length > 0) {
          displaySuggestions(data.suggestions, recognizedText);
        }
        
        document.getElementById('speech-status').textContent = '';
      } catch (e) {
        console.log('Error getting speech suggestions:', e);
        document.getElementById('speech-status').textContent = '';
      }
    }

    function displaySuggestions(suggestions, originalText) {
      const suggestionsDiv = document.getElementById('speech-suggestions');
      const buttonsDiv = document.getElementById('suggestion-buttons');
      
      // Clear previous suggestions
      buttonsDiv.innerHTML = '';
      
      // Add suggestion buttons
      suggestions.forEach(suggestion => {
        const btn = document.createElement('button');
        btn.textContent = suggestion;
        btn.className = 'px-3 py-1 bg-blue-100 hover:bg-blue-200 text-blue-800 rounded text-sm';
        btn.onclick = () => {
          const input = document.getElementById('text-input');
          input.value = suggestion;
          input.style.fontStyle = 'normal';
          input.style.color = 'black';
          hideSuggestions();
          // Optionally auto-send
          // sendText();
        };
        buttonsDiv.appendChild(btn);
      });
      
      // Add "Use original" button
      const originalBtn = document.createElement('button');
      originalBtn.textContent = `Use "${originalText}"`;
      originalBtn.className = 'px-3 py-1 bg-gray-100 hover:bg-gray-200 text-gray-800 rounded text-sm';
      originalBtn.onclick = () => {
        const input = document.getElementById('text-input');
        input.value = originalText;
        input.style.fontStyle = 'normal';
        input.style.color = 'black';
        hideSuggestions();
      };
      buttonsDiv.appendChild(originalBtn);
      
      // Add "Try again" button
      const retryBtn = document.createElement('button');
      retryBtn.textContent = 'Try speaking again';
      retryBtn.className = 'px-3 py-1 bg-red-100 hover:bg-red-200 text-red-800 rounded text-sm';
      retryBtn.onclick = () => {
        hideSuggestions();
        // Clear input and start recording again
        document.getElementById('text-input').value = '';
        if (!isRecording) {
          micBtn.click();
        }
      };
      buttonsDiv.appendChild(retryBtn);
      
      // Show suggestions
      suggestionsDiv.classList.remove('hidden');
    }

    function hideSuggestions() {
      document.getElementById('speech-suggestions').classList.add('hidden');
    }

    // Auto-start roleplay (fetches and displays introduction line)
    startRoleplay();

    // Save DOCX of conversation and feedback (colored bubbles)
    document.getElementById('saveDocx').addEventListener('click', async () => {
      try {
        const docx = window.docx;
        if (!docx) { document.getElementById('error').textContent = 'DOCX library not loaded'; return; }
        const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, ShadingType } = docx;

        const children = [];
        const unitTitle = '{{ unit.title if unit else "Role Play" }}';
        const dt = new Date();

        // Header
        children.push(new Paragraph({
          heading: HeadingLevel.HEADING_1,
          children: [new TextRun({ text: `Role Play ‚Äî ${unitTitle}`, bold: true })],
        }));
        // Include student name if provided
        const studentName = (document.getElementById('student-name')?.value || '').trim();
        if (studentName) {
          children.push(new Paragraph({ children: [new TextRun({ text: `Student: ${studentName}`, size: 20 })] }));
        }
        children.push(new Paragraph({ children: [new TextRun({ text: dt.toLocaleString(), size: 20 })] }));
        children.push(new Paragraph({ children: [new TextRun({ text: " " })] }));

        // Conversation
        const transcriptEl = document.getElementById('transcript');
        const rows = Array.from(transcriptEl.children);
        for (const row of rows) {
          const bubble = row.firstElementChild; if (!bubble) continue;
          const roleIsUser = row.className.includes('text-right');
          const textDiv = bubble.firstElementChild; const raw = textDiv ? textDiv.innerText.trim() : '';
          if (!raw) continue;
          const fill = roleIsUser ? 'DBEAFE' : 'E5E7EB'; // blue-100 vs gray-200
          const paras = raw.split(/\n/).map(line => new Paragraph({
            shading: { type: ShadingType.CLEAR, color: 'auto', fill },
            children: [new TextRun({ text: line })],
          }));
          const ts = new Date().toLocaleString();
          // Include duration if available
          if (state.completedMs != null) {
            const mins = Math.floor(state.completedMs/60000), secs = Math.floor((state.completedMs%60000)/1000);
            const dur = `${mins}m ${secs}s`;
            children.push(new Paragraph({ children: [new TextRun({ text: `Duration: ${dur}` })] }));
          }
          children.push(new Paragraph({ children: [new TextRun({ text: `Generated: ${ts}` })] }));
          children.push(...paras);
          children.push(new Paragraph({ children: [new TextRun({ text: " " })] }));
        }

        // Feedback
        const fbBody = document.getElementById('feedbackBody');
        const fbText = fbBody ? fbBody.innerText.trim() : '';
        if (fbText) {
          children.push(new Paragraph({ heading: HeadingLevel.HEADING_2, children: [new TextRun({ text: 'End-of-Conversation Feedback', bold: true })] }));
          const fbParas = fbText.split(/\n/).map(line => new Paragraph({ children: [new TextRun({ text: line })] }));
          children.push(...fbParas);
        }

        const doc = new Document({ sections: [{ properties: {}, children }] });
        const blob = await Packer.toBlob(doc);
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${unitTitle.replace(/\s+/g,'_')}_transcript_${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}-${String(dt.getDate()).padStart(2,'0')}.docx`;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(a.href);
        document.getElementById('status').textContent = 'DOCX saved. Reminder: save your log, complete your handout, and upload the handout, the log, and the video.';
      } catch (e) {
        document.getElementById('error').textContent = 'Failed to save DOCX';
        console.error('Failed to save DOCX', e);
      }
    });

</script>
</body>
</html>
